# Bootiful Spring Boot 3.2 

NB: the code [is here](https://github.com/joshlong/bootiful-spring-boot-3/tree/main/02-2024/service)

- Hi , Spring fans 
- im josh long i work on the spring team 
- im a kotlin gde
- im a java champion 
- and im of the oopiunon that theres never been a better time to be a java and spring boot developer. 
- i say that fuly aware of where we stand in the sopan oof things today. its been 21+ years siunce the ea releases of spring framework and 11 years since the ea releases of spring boot. this year will be 20 years since the 20 year mark since spring framework and 10 year mark since sprint boot. 
- so when i sayu theres never been a better time, bare in mind ive been in this for the better part of those decadxes. i Love the jvm and spring, and its been amazing. 
- but this is the best time. its never been close. so, lets develop a new application, as always, by visiting start.spring.io and well seee what i mean
- click `add` and choose `spring web`, `spring data jdbc`, `openai`, `graalvm native support`, `docker compose`, `postgres`, and `devtools`. 
- give it an artifact name. i called my service... `service`. im great with names. i get that from my dad. my dad was also amazing with names. when i was a small boy we had a tiny little white dog and my father named him _white dog_. he was our family pet for years. but after around tne years he disappeared. im not sure what happened to him after all. maybe he got a job. i dont know. but then miraculously another small white dog apepared tapping on our screen door. so we took him in and my father named him 'too'. or 'two'. i don't know. anyway, _great_ with names. tho, that said, my mom tells me all the time that im very lucky she named me... that's probably true.
- anyway, choose java 21. this party is key. you can't use java 21 if you don't use java 21. so you need java 21. but we are also going to use graalvm for its native image capabilities. 
- java 21 is amazing. iuts a far sight better than javba 8. its technically superior in every way. its faster, it more robust. its more syntax rich. its also morally  superior. u wont like the loook of shame and disgrace in uyr chuildrends eyes when they see ur usin gjava 8 in production. dont do it. be the change u wanna see in the world. use java 21. 
- dont have java 21 installed? download it! use the fantastic sdkman.io tool: `sdk use java 21-graalce`. ad then make it your default,  `sdk default java 21-graalce `. open a new shell. downlaod the zip file. 
- youll get a zip file. unzip it and open it in your ide. im using intellij idea, and it installs a command line tool called `idea`. you can use it to open the project. `cd` into the directory and then run `idea build.gradle`. or. if u chose maven, choose `idea pom.xml`.
- now then this is a new application and its going to be taliing to a database. its a data centric application. on the intiailizr we configured postgres, but nwo we nee to connect to it. the last thing we want is a llong readme with a milliuon steps to development. we want to live that git-clone-run life. 
- to that end the spring initializer generated a compose.yml file that contains a definition for Postgres, the SQL database. Andf, even better, spring boot is configured to automatically launch that continer when the applicatino starts up. No need to configure connectivity details like `spring.datasource.url`, etc. Its all done with autoconfiuguration. Ya love to see it! 
- and, never wanting to leave a mess, Spring boot will shutdown the docker containers on application shutdown, too. 
- we want to move as quickly as possible. to that end, weve added devtools to the build on the spring initializr. its allowing us to go quickly. the core conceit here is that restarting java ios pretty slow. restarting spring is really quickl, however. so, what if we could just take note of newly compiles class files, load them into the classloader, and then create a new spring application context, discarding the old one? thats exactly what spring's devtools do. run it during development and see ur restart time diminish by huge fractions. 
- trhis works because, again, spring is super quick tostartup. _except_, that is, when you are launching a PostgreSQL database on each restart. I love postgresql, but, uh, yah, it's not meant to be constantly restarted each time ur tweaking method names and http endpioint paths and css and such. So, lets configure it to stay running 
- :: show dockercompose lifecycle property  ::
- alright, now lets go ahead and build a data centric application. 
- well start with a simple record
- :; show code for a record for `Customer` ::  // look mom, no Lombok! 
- i love records! and you should too! Dont sleep on recoerds. this innocuous little record isnt just a better way to something like Lombok's `@Data` annotation does, its actually part of a handful of features that, culminating in java 21 and taken together, support something called _data oriented programming_.
- java language architect brian goetz talks about this in his InfoQ article on Data Oreinted Progtramnming in 2022. 
- java has doiminate the world of the monolith, the reasoning goes, because of its strong access control, good, quick compiuler, privacy7 protections, and so on. java makes it easy to create relatively modular, composable, monolityhic applicatiohns. Monolithic applicatiohns are typiclaly large, sprawling codebases, and java supports it.
- but things have changed. as often as nt, the vector by which we expresss change in a system these days is _not_ the specialized implementations of deep seated hierarchies of abstract types -  through dynamic dispatch and polymorphism - but instead in terms of the often adhoc messages that get sent across the wire, via HTTP/REST, GRPC, messaging substraits liek Apache Kafka, etc. its the data, dummy. 
- java has evolved to support htese new patterns. 
- lets take al ook at four key features - records, pattern matching, smart switch expressiopns, and sealed types - to see what i mean. suppose we work in a heavily regulated industry, like finance. 
- imagine we have an itnerface caleld `Loan`. Werll, obviously, loians are heacvily regulated financial instrucments. we dont want somebody coming along and adding an anonymous inner class implementation of the `Loan` interface, sidestepping the validation and protection wer've worked so earnestly to build into the codebase. 
- so, we'll use `sealed` types. 
- ::show the Loan, UInSecured Loan, and SecuredLoan, as sealed types ; make the UnsecuredLoan a record:: 
- sealed types are a new sort of acess control or visibility modifier. nice! 
- now, lets ay i wanted to display a mesage for each type of loan. ill code up a method. heres the naive first implementation. 
- :: show the version with the if instance checks and the standalohne variable and so on.::
- this works, sort of. but its carrying its weight. 
- we can clean it up. take advantage of pattern matching. like this. 
- :: show a version that has `f  instance Foo foo`;  this is much better! its cleaner and more expressive. 
- better. but what happens if i comment out one of the branches? ntohing! the compiler doesnt care. bt now were noit handling one of the ctritical paths that this code could go. 
- like wise, i have this vlaue stored in a value and im assigning to it based on teh results of some condition. would that ic ould cut out the middle variable and just returen some expression! 
- lets lok at a cleaner implementation. 
- :: show the version with a smart switch exprtession and pattern matching::
- thuis version uses smart switxh expressesions to return a value, pattern matching. if u comment out one of the branches, the compiler wioll bark, because - thanks to sealed types - it knows that u havent exhausted all possible options.
- nice! the compiler is doing a lot of work for us! the result is both cleaner and more expressive. mostly.
- the problem is i have this wasted variable usl, which i use just to derefence the value. but i made that type a record.
- records are java' answer to tuples. they are tuples. its just java is a nominal language; things have names. this tuple has a name, too. and records give us a lot of power, if we agree the contract they imply. the core conceit of records is that the identiyf of the object is equal to the identity of the fields - theyre claled 'components' - in a record. so  in this case the identity of the record is equal to the identity of the `interest` variable. if we agree that, then the compiler can givew is a constrcutor, it can give us storager for each of the components,. it can give us a toiString m ethod, a hashCode method, and an equals method. And itll give us accessors for the components in the constructor. Nice! 
-  AND, it can support destructuring! so lets reivist the example to rework it so that we hosit out the value of the interest field, ignoring the rest of the class. this is an example of records and pattern matching working together. nice! the result is _much cleaner_!
- ::show the finished result::
- so, back to our regulalry scheduled programming. lets remove all of this. t'was just a distraction. we have a record for our entity.
- add an interface for the repository and a controller. notice that this takes an exceedingly long period of time! thats because behind the scenes its using the docker deaemon to startup the postgresql instance. 
- but henceforth, were going to use devtools. only need to recompile. if the app is running and ur using elcisep or vs code u will only need to save the file., but intellij doesnt hav a 'save' option. force a build with cmd shift f9. nice. 
- all right, weve got our web endpoint babysitting a database, but theres nothing in the database, so this will fail, surely. lets initialize our sql db with some schema and sample data. 
- add `schema.sql` and `data.sql`. make sur eto tell spring boot to run the sql files on startup. 
- ::show the sql files:: 
- nice. now lts reload the app. cmd shift f9. on my computer that reload is about 1/3 the time it takes to startup the application itself.
- its up and running visit. `http://localhost:8080/customers` to see the results. it worked. of course it worked! it was a demo. 
- this is all pretty stokc standard stuff. u couldve done somethng similar ten year ago. mind u the code would'v been far more verbose. javas improved by leaps and bounds since then. and of course the speeds wouldnt have been comparable. and of course the abstractions r better now. but u couldve done smething like thi a long time ago! 
- that said, things change. there are alwaysd new frontiers. right now, the new frontier is AI. because the search for good ol' I wasnt hard enough. 
- AI is a huge industry, but whatr most people mean when they thihnk of AI is _leveraging_ AI. you dont need to use Python to use large language models (LLMS), in the same way that most folks dont need to use C and write their own SQL dbs. You just need to integrate with the LLMs and here  java is second to none for choice and power. 
- At our last [springone  2023](https://springone.io/history-of-spring) event,  we announced Spring AI a new project that aims to make integrating and working with AI as easy as possible. 
- sure, there are bindings for _all_ the LLMs you could possibly want - Pinecone, Bedrock, Azure openai, Google Gemini,   Ollama, HuggingFace, and of course OpenAI itself, but that' sjust the beginning. you see, LLMs are baked into a model and that modwel then informs the LLMs understanding of the world. but that model has a cut off date, after which its knowledge is stale. So if u wantr to build, say, an IVR that fields reqwuests for a users bank acount, then that LLM is going to need to be aprised of the up-to-date state of the world when it does so. You can add information in the request that you make and use it as context to ifnrom the response. if it wer eonly this simple, then that wouldn't be sob ad. theres' another wrinkle. diffwernt LLMs support different context windows sizes. how much data can you send (adn receive) for a given request. the smaller the window, the less information you can send, the less informed the LLM will be in its response. 
- one thing you might do here is to put the data in a vector store, like pgvector, Neo4j, Weaviate, or otherwise. vector stores give u the abiluity to, given a word or sets of words, find other things that are similar to them. it stores data as mathematical representations and lets you querty for similar things. so, youll want to ingest data. say from an account, or a set of pdfs. youll want to store them for easy retreiival in a vector datagbase. and youll want to then integrate with an LLM, giving it data from tehat vectordb. this whole process of ingesting, enriching, and analysing dfata so as to inform the response from an LLM is called Retreival Augmented Generation (RAG). 
- RAG is the purview of Spring AI. Were not goiuing to leverage all those capabilities. for more, see this Sping RTips video i did on Spring AI.
-  but we can do something quick and easy demo here. 
- ::show the code for a sttory controller :: 
- cmd shift f9 and you can visit the endpoint. it might take a few seconds so get that cup of coffee or water or whtver ready for a quick sip. 
- ther eit is! we live in an age of miracles! the  age of the frewwaking singularity! you can do anything now. 
- heres wht i got when I ran it:
- ::show the output of a given run:: 
- but it did take a few seconds. which, again, i dont begrudge the computer that time. it did a splendid job! i couldnt do that any faster. just look at the story it rendered! 
- but, it did take a while. and that has scalability implications for our applications. 
- remember, behind the scens when we make a call to our LLM were making a netwopr call. somewwhere, deep in teh bowels of the code there's a java.net.Socket from which we've obtained an `InputStream` that represewnt the bytes coming from the service. I dont know if you remember using InputStreeam directly. heres an example:
- :: show a while look reading form an InputStream one byte at a time:: 
- see thatr part where we read bytes in fromn the inputStream by callin `InputStream#read`? we call that a blocking operation. If we call `InputStream#read` on line four, then we must wait until the call returns untl we can get to line five. 
- what if theres siply too muych data?  what if the service is down? what if it never returns? what if were stuck waiting in perpetuity? _what if_? 
- this is tedious if it only happens once. but its an eexistential problem for our services if it can happen on every thread in the system used to service http requests! this happebs a lot. its the reason why its possible to login to an unresponsive web server and find that the cpu is basically asleep, doing absolutely nothing or little at all. all the the threads in the thread pool are stuck in a wait state waiting for someting thats not coming. 
- this is a huge waste of the valuable CPUs we paid for. and the best case scenario is stil not good. even if it will eventualy return, it still means that the thread on which that request is being handle is unavalable to anything else in the system. its just idling, monopolizing that thread so nobody else in the system can use  it. this wouldnt be an issue if threads were cheap and infite. but theyre not. for most of java's lifetime, each new thread was paired 1:1 with an operating system thread. and it was not cheap. theres a certain amount of bookeeping associated with each thread. 1 to 2 mergabytes. so you cant creeate lots of threads and ur wasting those threads, too! 
- theres got to be a better wazy. 
- u can use non bloicking io. things like the hemorrhoid inducinglyu copmplex Java NIO library. this is an option, but not a fn one. most of us don't think in terms of non blocking IO, or regular IO, anyway. we live at highers rungs of the abstractoin stack. so we could use reactiv eprogramming. i love reactive programming. i even wrote abook about it (link to _Reactive Spring_). but its not exactly obvious how to make that work if youre not used to thinking functionally. its a diffrerent paradigm and implies a rewrite of your code. 
- what if we could have our non blocking cake and eat it too? 
- with java 21, now we can! theres a new feature called virtual threads that makes this tuff a tohn easier~! 
- if u do somethinb blocking on a new _virtual thread_, the runtime willdetect tht youre doign a blocking thing - like `InputStream#read`, `OututStream#write`, and `Thread.sleep` - and move that blocking, idle activity off  of the thread and into RAM. Then, itll baiscally7 set an egg timer or monitor the file descriptor and let the runtime repurpose the thread for something else. wehn the blocking action has finished, the runtime moves it back onto a thread and lets it continue. itrs hard to undestand, so lets look at it by way of an example. i stole this example shamelessly from Oracle Developer Advocatre José Paumard. 
- :: shopw the threads example  :: 
- on line $$REPLACE_ME$$, the constructor were usiung creates regular standard old platform threads, identical in nature to the threads weve created basically since javas debut in the '90s. the program creates 1000 threads. in each thread we sleep for 100 milliseconds, four times. in between, we test if we're on the first of the 10000 threads, and if we are, wer note the current threads name by adding it to a set. a set dedupes its elements. so if the same name appears more than once, well still only hveone leement in the set. 
- run the program (cmd shift f9!) and youll see that the physics of the program are unchanged. 
- now, change that constructor to use _virtual threads_. Super easy change. and now run the program. cmd shift f9! and youll see that there are more than one element in the set! You didnt change the core logic of your cvode at all. and indeed you ohnly even had to change ONE thing,b ut now, seamlessly, behind the scenes, the compile and the runtime rewrote ur code sot hat wehn this blocking thing happens, the runtime seamlessly takes you off and puts u back on threads. this means that the thread on which you existed before is now avaolable to other parts of the system. ur scalability is ging to go through the roof! 
- and u might protest, well i dont want to have thcange all my code. first, thats a ridiculous argument, the change is trivial. but, u might continue, ur using an `ExecutorService`. Fair point. And there's a new viertual thread exewcutor as well: `Executors.newVirtualThreadPerTaskExecvutor()`. Nice! ifd youre usding spring boot, then you know you can change all sorts of aspects about the program by exporting beans of a given type - in this case ExecutorService. Spring Boot will pull that in and defer to it instead. 
- easy enough. but if ur using spring boot 3.2 (you are, surel, using spring boot 3.2, right?), then you need only set this property! `spring.threads.virtual.enabled=true`. Nice! No code changes required. And now u should see much improvbed scalability, andf mightr be able to scale down some of the instances in ur load balancer, if ur services are IO bound. my suggestion? tell ur boss ur gonna save the company a ton of cash but insist u want that money in ur paycheck. then deploy this change. voilà! 
- all right, were moving quickly. weve got git clone run-ability. weve got docker compose support. weve got devtools. we havef a very nice language and syntax. weve got the freaking singularity. were moving quickly. weve got scalability. add the spring boot actuator to the build and now youve got observability. i think its time we turned to production. 
- i wanna package this application up and make it as efficient as possible. here, my friends, there are a couple of things we need to consider. first of all how do we containerize the application? simple. use buldpacks. easy. remember, friends dont let friends write dockerfiles. use builcpacks. theyre supported out of the box with sprin boot, too: `./gradlew buildBootImage` or `./mvnw spring-boot:build-image`. tghis isnt new tho, so next question. 
- how do we get this thing to be as efficient and optimized as possible? and before we dive into this, my friends, its important to remember that java is already very very vcery efficient. i love [this blog](https://thenewstack.io/which-programming-languages-use-the-least-electricity/) from 2018, before the covid pandemic, or _BC_. 
- it looks at which languages use the least energy, or are the most energy efficient. 
- c is the most energy efficient. it uses the least electricity. 1.0. its the baseline. its the efficient... for MACHINES. not people. definitely not for people. 
- then we have Rust and itrs zero cost abstractiohns, well done.
- then we have C++ ::spit on the floor in outrage::  Disgusting! Moving on.
- then we have Ada, but who cares. 
- then we hava java, whjich is nearly 2.0. lets just roundup. 2.0. its twice as inefficient as c. or 1/2 as efficient as c. 
- so far so good? greeat. its in the top 5 most efficient languages, tho! 
- if u scroll the list youll see some amazing numbers. go and c# coming in in the 3.0 range. scroll down hewre and we have javascript and typescript, one of hwich - to  my endless bafflement - is 4x less efficient than the other! 
- then we have PHP and Hack, the less said about which the better. Moving on. 
- then we have JRuby and Ruby. Friends, remember jruby is ruby written in java. and ruby is ruby written in  c. and yet jruby is almost a 1/3 more efficient than ruby! jhust by dinn of having been written on the jvm. its an amazing piece of kit. absolutely phenomenal. 
- then...we have python. and this... this makes me sad! i love python! ive been using python since te 90s! bill clinton was president when i first learned python! but these numbers r _not_ great. think aboutit. 75.88. lets round up to 76.im not great at math. but you know what is? freaking python! lets ask it. 76/2 is.. 38. 38! that means that if you ran a program in java, and the generation of the energy required to run it created a bit of carbon that got trapped in the atmosphere and that carbon in turn ckilled ONE tree, then the rquivalent program in python would kill THIRTY EIGHT trees! thats a forest! that's worse than bitcoin! 
- we need to do something about this, and soon. 
- anyway, i guess that's neither here nor there. suffice it to say that java is already _amazing_.
- i think this is becauswe of two things that people take for graneted: garbage colection and JIT . 
- garbage collection, well we all know what it is. Hck, [even the WhiteHouse appreciates garbage collected, memory safe ](https://www.whitehouse.gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf) languages like Java in its recent report on securing software to secure the building blocks of cyberspace. 
- garbage collection lets us write mediocre softeare and sort of.. get awa with it. its dope.
- and JIT - tghe just in time compiler - is another amazing piece of kit. it anqalsyses freequently acessed codepaths in ur applkication and turns them into operating system and architecture specifi native code. it can only do this for some of your code tho. it needs to know that the types that are in play when u compile the code are the only types that will be in play when u run the code. and some things in java - a very dynmamic language with a ruytnime thats more akin to that of javbascript, ruby, and python - allow java programs to do thing sthat would violate this constraint. things like serialization, jni, ereflection, resource loading, and jdk proxies. remember, its posibe, with java, to hava a `String` that has as its contents a java source code file, ocmpile that string into a .class file on the file system. load the .class file into the classloader. refelctively create an instance of that class. and then - if that class is an interface - to creatre a jdk proxy of that class. and if that class implements sertializable - to write that class over a network socket and load it on another jvm. all without every having an explicit typed reference to anything besides `java.lang.Object`! It's an amazing language,. and this dynamic nature makes it a very productive language. but it also frustrates the JITs attempt at optimizations. 
- but still, it does an amazing job where it can. and the resutls speak for themselves. so, one wonders, why couldnt we proactivey JIT the whole program? ahead of time. and we can. theres an openjdk distribution called graalvm that has a number of nicetiies that extend the openjdk release with textra toolsl llike the native image compiler. the native image compiler is dope. but this nativ eimage compiler has the same cosntraints. it cant do its mnagic for very dynamic things. which is a problem. as most code - your unit testing libraries, ur web frameworks, your ORms, your logging libraries... everythign! - use one or all of those dynamic behaviors. 
- there is an escape hatch. you can furnish configuration in the fgorm of `.jso` files to the graalvm compiler. these .json files have two problems. 
- first, it sounds stupid. i dont like saying the word "JAY-SAWN". as an adult i cant believe we say these things to each other. i speak french, and in french you'd pronounce it '.gison' (jeeesã). much nicer.  the hokkien language has a word - _gingsong_ (happiness), which also coudl work. so you could have .gingsong. pick your team! either way, its a big improvement over `.json`. im team `.gison`, but it doesnt really matter. 
- thats the first problem. the econd problem is that, well, theres jst so much darned .gison required! again, just think about all the plces its requirted! its endless. i dont have time to write artisanl hadn crafted confiuguration files for every program. i dont even have nough time of finish this blog! 
- so, well use the Sprig Boot 3 aot engine instead. the aot engine analyses the beans in ur Spring Application and emits the requisite .gison files for you. Nice! there's even a whole component model thart you can use that extends Speint to compile time. i wont get itno all of that here, but you can ready my [fgree e-book]() or watch my free youtube video introducing all things [Spring and AOT]().
- so lets kick off that build: `./gradlew nativeCompile` 
- this will take a little while . remember, its doing an analysis of everything in ur codebvase - be it the libraries on the classpath, the jre, and ur code itselfr - to determiner which types it should preserver and which it should throw out. the result is a lean mean lightning fast binary - but at the cost fo a very slow compilation. 
- it takes so long in fact, that it kinda just gums up the works. stops me dead in my tracks, waiting. im, like the platform tghreads of earlier on in this very blog, _blocked_. and i get bored. waiting. waiting. sometimes i start to hum music. or theme songs. or elevator music. u know what elevator music sounds like, right? ceasless, endless. so, i thought, wouldnt it bwe great if everyone heard elevator music? [so i asked. ]() and i got some great responses.
- one response sggested that having a beeping sound would be useful. coudlnt agree more. my stupid microwave iwll make a _ding!_ sound when its done. why couldnt my multi million line compiler? 
- another suggested that we should play this elevator music from the soundtrack to the nintendo 64 videdo game to the first pierce brosnan outing as James Bond, _Goldeneye_. I like it. 
- and then we got this response, from another one of my favorite doctors, Dr. Niephaus, who works on teh graalvm team. he said that adding elevator music would only just fix the symptoms, and not the cause of the problem, which is making graalvm even more efficient in terms of time and memory. ok. but he did share this promising prototype! 
- ::sho the tweet with the native image compiler being updated:: 
- im sure itll get merged any day now... 
- anyway... if u check the compilation, it should be done now. its in the `./build/native/nativeCompile/` folder, and its called `service`.
- run it. itll fail because, again - were living that git-clone-run lifestyle! we didnt specify any connectivity crededntials! so, run it with the following enviroment variables specified:
- :: show the `run.sh` contents :: 
- on my machine, it starts up in ~100ms! Nice! but i dont really all that much care about that because this is a standalone service. what i care about is the resident set size. note the proicess identifier - itll be in the logs - and then use `ps -oi rss <PID>` . itll dump out a number in kilobytes, so divide by a thousand and youll get the number in megabytes. on my mchine it takes just over 100mb to run. thats amazing! 
- we have a program that is concise as can be, easy to developer and iterate on. and it uses  virtual threads to give us unparalleled scalability. it runs as standalone, self-contained operating system specific native image. it supports the freaking singularity! amaing! we live in amazing time. and there's never been a better time to be a java and spring developer. i hope ive so persusaded you, too.
- if you enjoyed this blog, i hope youll subscribe to our youtube channel adn of course you can find me onm twitter here. thanks. 